package A_Cracking_The_Coding_Interview_6E.A_big_O_Examples;

public class Ex8 {

    /*

    Q. 여러 개의 문자열로 구성된 배열이 주어졌을 때 각각의 문자열을 먼저 정렬하고
       그 다음에 전체 문자열을 사전순으로 다시 정렬하는 알고리즘이 있다고 가정하자.
       이 알고리즘의 수행 시간은 어떻게 되겠는가?

    예상되는 추론 방식.
       각 문자열을 정렬하는 데 O(N logN)이 소요되므로 모든 문자열을 정렬하는 데 O(N*N logN)이 소요될 것이다.
       그 다음 전체 문자열을 다시 사전순으로 정렬해야 하므로 O(N logN)이 추가적으로 필요할 것이다.
       따라서 전체 수행 시간은 O(N^2 logN + N logN)이 되고, 이를 정리하면 O(N^2 logN)이 될 것이다.

    완전히 틀린 분석이다. 어디서 잘못됐는지 알아챘는가?
       바로 N을 서로 다른 두 가지 경우에 혼용해서 썼다는 점이다. 즉, 위의 추론에선 문자열의 길이를 나타낼 때와
       배열의 길이를 나타낼 때 모두 N을 사용했다.
       면접을 볼 떄 이와 같은 실수를 방지하기 위해 변수 'N'을 아예 사용하지 않거나 N이 가리키는 것이 명백한 경우에만 사용하는 것이 좋다.

    연상 가능한 이름을 사용해서 새로운 변수를 정의하자.
       - 가장 길이가 긴 문자열의 길이를 S라 하자.
       - 배열의 길이를 A라 하자.
       자, 이제 각 부분의 시간 복잡도는 다음과 같다.
       - 각 문자열을 정렬하는 데 O(S logS)가 소요된다.
       - A개의 문자열 모두를 정렬해야 하므로, 총 O(A*S logS)가 소요된다.
       - 이제 전체 문자열을 사전순으로 정렬해야 한다.
         총 A개의 문자열이 있으므로 이들을 정렬하는 데 O(A logA)가 소요될거라 생각할 수도 있다.
         하지만 문자열을 비교하는 시간 또한 고려해야 한다.
       - 문자열 두 개를 비교하는 데 O(S) 시간이 소요되고, 총 O(A logA)번을 비교해야 하므로
         결론적으로 O(A*S logA)가 소요된다.
       - 위의 두 부분을 더해주면 전체 시간 복잡도는 O(A*S(logA+logS))가 된다.

    */

}
