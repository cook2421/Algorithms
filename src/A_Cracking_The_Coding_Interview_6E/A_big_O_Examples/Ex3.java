package A_Cracking_The_Coding_Interview_6E.A_big_O_Examples;

public class Ex3 {

    void printUnorderedPairs(int[] array){
        for(int i=0; i<array.length; i++){
            for(int j=i+1; j<array.length; j++){
                System.out.println(array[i] + ", " + array[j]);
            }
        }
    }
}

/*

[[[1. 반복 횟수 세어보기]]]
처음에 j는 N-1번 반복한다.
그 다음에는 N-2번, N-3번, ... 이런 식으로 반복 횟수가 계속 줄어든다.
따라서 총 반복 횟수는 다음과 같다.
    (N-1) + (N-2) + (N-3) + ... + 2 + 1
    = 1 + 2 + 3 + ... + N-1
    = 1부터 N-1까지의 합
1에서 N-1까지의 합은 'N(N-1)/2'이 되므로 수행 시간은 O(N^2)이 된다.


[[[2. 코드가 무엇을 의미하는가]]]
위 코드는 j가 i보다 큰 모든 (i, j) 쌍을 반복하고 있다.
전체 쌍의 개수는 N^2이 된다. 대략 이 중 절반이 'i<j'인 경우일테고 또다른 절반이 'i>j'인 경우일 것이다.
따라서 이 코드는 대략 전체 쌍의 절반인 N^2/2개를 사용하므로 O(N^2) 시간이 걸린다.


[[[3. 결과를 그림으로 나타내보자]]]
위 코드는 N=8인 경우 다음과 같은 (i, j) 쌍을 반복한다.

(0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7)
       (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7)
              (2, 3) (2, 4) (2, 5) (2, 6) (2, 7)
                     (3, 4) (3, 5) (3, 6) (3, 7)
                            (4, 5) (4, 6) (4, 7)
                                   (5, 6) (5, 7)
                                          (6, 7)
이는 N x N의 절반 크기인 N^2/2 크기의 행렬처럼 보인다.
따라서 O(N^2) 시간이 소요된다.


[[[4. 평균을 이용한 방법]]]
바깥 루프가 N번 반복한다는 것은 자명하다.
안쪽 루프는 얼마나 많은 일을 하고 있을까? 이는 바깥 루프의 상태에 따라 달라지지만, 반복횟수의 평균을 구해볼 수 있다.
1,2,3,4,5,6,7,8,9,10의 평균은 무엇인가?
이들의 평균값은 중간값으로 대충 5쯤 될 것이다.(물론 정확하게 계산할 수도 있지만 big-O에서는 그럴 필요 없다)
1,2,3,...,N일 때는 어떠한가?
이 수열의 평균값은 N/2가 될 것이다.
따라서 안쪽 루프의 평균 반복횟수는 N/2이고 이 루프가 총 N번 수행되므로 전체 수행횟수는 N^2/2, 즉 O(N^2)이 된다.

*/