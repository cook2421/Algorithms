동적계획법(DP, Dynamic Programming)


[정의]
큰 문제를 작은 문제로 나누어 푸는 문제를 일컫는다.
동적계획법이라는 말 때문에 어떤 부분에서 동적으로 프로그래밍이 이루어지는지 찾아볼 필요가 없다.
'동적프로그래밍'이라는 말을 만든 사람도 이것이 단지 멋있어서 붙인 이름이라고 했다.


[비교]
분할정복(DC, Divide and Conquer)과 비슷하다.
하지만 '작은 문제의 중복 여부'에 따라 나뉜다.
분할정복은 큰 문제를 해결하기 어려워 단지 작은 문제로 나누어 푸는 방법이다.
특징은 작은 문제에서 반복이 일어나는 부분이 없다는 점이다.
동적프로그래밍은 작은 부분 문제들이 반복되는 것(답이 바뀌지 않음)을 이용해 풀어나가는 방법이다.


[방법]
모든 작은 문제들은 한번만 풀어야 한다.
따라서 정답을 구한 작은 문제를 어딘가에 메모해 놓는다.
다시 그보다 큰 문제를 풀어나갈 때 똑같은 작은 문제가 나타나면 앞서 메모한 작은 문제의 결과값을 이용한다.


[조건]
1. 작은 문제가 반복이 일어나는 경우
2. 같은 문제는 구할 때마다 정답이 같음


[메모이제이션 Memoization]
동적프로그래밍에서는 작은 문제들이 반복되고 이 작은 문제들의 결과값이 항상 같다.
이 점을 이용하여 한 번 계산한 작은 문제를 저장해놓고 다시 사용 한다.
이것을 Memoization이라고 한다.

피보나치 수를 예로 들어보자.
피보나치는 1,1,2,3,5,8,...의 수를 이룬다.
즉, '다음 수 = 한 단계 전의 수 + 두 단계 전의 수'라는 점화식을 갖는 수열이다.
재귀함수로 풀게 되면 이보다도 훨씬 간단하게 풀 수 있지만
n이 증가함에 따라 호출되는 함수의 수가 기하급수적으로 증가하기 때문에
일정 수 이상의 수열을 구하기가 어렵다.
또한 재귀함수로 풀게될 경우, 했던 작업을 또 하게 된다.
이 때 위에서 살펴본 동적계획법의 두 가지 조건을 상기해보면 동적계획법을 통해 풀 수 있다는 사실을 알 수 있다.

    1) 작은 문제들이 반복된다.
       F(5)를 구하기 위해서는 F(4), F(3)이 필요하다.
       다시 F(4)를 구하기 위해서는 F(3), F(2)가 필요하다.
       이 경우를 살펴보면 F(5)에서도 F(3)이, F(4)에서도 F(3)이 필요함을 알 수 있다.
       즉, 작은 문제가 반복되는 구조이다.

    2) 같은 문제는 구할 때마다 정답이 같다.
       피보나치 수열의 첫번째, 두번째 수는 각각 1로 고정되어 있다.
       즉, 3번째 수열은 언제나 결과가 2이다.
       또 4번째 수열은 3번째 수열과 2번째 수열을 이용해 구하므로 언제나 정답이 같다는 사실을 알 수 있다.


[구현 방법]
1. Bottom-up
   작은 문제부터 차근차근 구해나아가는 방법이다.

2. Top-down
   재귀함수로 구현하는 경우가 대부분 Top-down이라고 생각하면 된다.
   큰 문제를 풀 때 작은 문제가 아직 풀리지 않았다면 그제서야 작은 문제를 해결하게 된다.

Top-down의 경우 소스의 가독성이 좋아지는 장점이 있지만, 작성하기가 조금 어렵다는 단점이 있다.
Bottom-up의 경우 풀기는 쉽지만 소스의 가독성이 저하될 수도 있다.